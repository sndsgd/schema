<?php declare(strict_types=1);

namespace sndsgd\schema\renderers;

use ReflectionClass;
use sndsgd\Classname;
use sndsgd\schema\Rule;
use sndsgd\schema\Type;
use sndsgd\schema\types\AnyType;
use sndsgd\schema\types\OneOfObjectType;
use sndsgd\schema\types\ScalarType;

class RenderHelper
{
    public static function getClassComment(Type $type): string
    {
        return <<<COMMENT
        /**
         * GENERATED CODE! DO NOT EDIT!
         * This file was generated by the sndsgd/schema library
         *
         * Name: {$type->getName()}
         * Description: {$type->getDescription()}
         */

        COMMENT;
    }

    public static function renderRuleCreateAndValidate(
        Rule $rule,
        string $variableName,
        bool $translateDescription = true
    ): string
    {
        $reflection = new ReflectionClass($rule);
        $class = $reflection->getName();

        $ret = "";
        $ret .= "        \$$variableName = (new \\$class(\n";
        foreach ($reflection->getProperties() as $property) {
            $property->setAccessible(true);
            $value = $property->getValue($rule);
            $value = var_export($value, true);

            if ($translateDescription && $property->getName() === "description") {
                $value = "_($value)";
            }

            $ret .= "            $value,\n";
        }
        $ret .= "        ))->validate(\$$variableName, \$path);\n\n";

        return $ret;
    }

    public static function getTypePsr4Path(string $baseDir, Type $type): string
    {
        $relpath = str_replace(".", "/", $type->getName()) . ".php";
        return "$baseDir/$relpath";
    }

    public static function getDocReturnTypeForOneOfObject(OneOfObjectType $type): string
    {
        $ret = "";
        foreach ($type->getTypeMap() as $objectType) {
            if ($ret !== "") {
                $ret .= "|";
            }
            $ret .= self::getTypeHint($objectType);
        }
        return $ret;
    }

    public static function getTypeHint(Type $type): string
    {
        if ($type instanceof ScalarType) {
            $typehint = $type->getRules()->getTypeName();
            switch ($typehint) {
                case "integer":
                    return "int";
                case "boolean":
                    return "bool";
                default:
                    return $typehint;
            }
        }

        if ($type instanceof AnyType) {
            return "mixed";
        }

        return "\\" . Classname::toString($type->getName());
    }

    public static function createClassnameFromString(string $class): Classname
    {
        $parts = Classname::split($class);
        return new Classname(implode("\\", $parts));
    }
}
